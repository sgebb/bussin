@using Bussin.Models

<style>
    /* Hide number input spinners */
    .no-spinners::-webkit-inner-spin-button, 
    .no-spinners::-webkit-outer-spin-button { 
      -webkit-appearance: none; 
      margin: 0; 
    }
    .no-spinners {
      -moz-appearance: textfield;
    }
</style>

@if (IsVisible)
{
    <div class="modal fade show d-block" tabindex="-1" style="background-color: rgba(0,0,0,0.5); z-index: 1050;" @onmouseup="HandleBackdropMouseUp">
        <div class="modal-dialog" @onmousedown="HandleContentMouseDown" @onmousedown:stopPropagation="true">
            <div class="modal-content" @onclick:stopPropagation="true">
                <div class="modal-header">
                    <h5 class="modal-title">
                        <i class="bi bi-gear"></i> Peek with Options
                    </h5>
                    <button type="button" class="btn-close" @onclick="Close"></button>
                </div>
                <div class="modal-body">
                    <div class="row g-3 mb-3">
                        <div class="col-sm-6">
                            <label for="maxCount" class="form-label">
                                Max Messages
                                @if (HasMessageIdFilter)
                                {
                                    <span class="text-muted ms-1" style="font-size: 0.8em;">(1 for ID search)</span>
                                }
                            </label>
                            <input type="number" class="form-control no-spinners" id="maxCount" value="@maxCount" @oninput="OnMaxCountChanged" min="1" max="250" disabled="@HasMessageIdFilter">
                            @if (validationError != null)
                            {
                                <div class="invalid-feedback d-block">@validationError</div>
                            }
                        </div>
                        <div class="col-sm-6" style="@(peekFromNewest ? "visibility: hidden;" : "")">
                            <label for="fromSequence" class="form-label">From Sequence Number</label>
                            <input type="number" 
                                   class="form-control no-spinners" 
                                   id="fromSequence" 
                                   @bind="fromSequenceNumber" 
                                   min="0" 
                                   disabled="@peekFromNewest">
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <div class="form-check">
                            <input class="form-check-input" type="checkbox" id="peekFromNewest" checked="@peekFromNewest" @onchange="OnPeekFromNewestChanged" disabled="@(!AllowReversePeek)">
                            <label class="form-check-label @(!AllowReversePeek ? "text-muted" : "")" for="peekFromNewest">
                                Reverse peek (LIFO)
                                @if (!AllowReversePeek)
                                {
                                    <span class="ms-1" style="font-size: 0.8em;">(Not available with search filters)</span>
                                }
                                <i class="bi bi-info-circle text-muted ms-1" 
                                   style="cursor: help;" 
                                   title="Attempts to peek the newest messages (LIFO - Last In First Out). Note: This is a best-effort calculation based on message counts."></i>
                            </label>
                        </div>
                    </div>

                    <!-- Search Filters Section -->
                    <div class="card mb-3" style="background-color: var(--bg-color); border-color: var(--border-color);">
                        <div class="card-header py-2 d-flex align-items-center">
                            <i class="bi bi-funnel me-2"></i>
                            <span>Search Filters</span>
                            <i class="bi bi-info-circle text-muted ms-2" 
                               style="cursor: help; font-size: 0.85em;" 
                               title="Filters are applied client-side by scanning through messages. All filters use case-insensitive partial matching."></i>
                            @if (HasActiveFilters)
                            {
                                <span class="badge bg-primary ms-auto">@ActiveFilterCount active</span>
                            }
                        </div>
                        <div class="card-body py-2">
                            <div class="mb-2">
                                <label for="messageIdFilter" class="form-label small mb-1">Message ID</label>
                                <input type="text" class="form-control form-control-sm" id="messageIdFilter" value="@messageIdFilter" @oninput="OnMessageIdFilterChanged" placeholder="Search by message ID...">
                            </div>
                            <div class="mb-2">
                                <label for="subjectFilter" class="form-label small mb-1">Subject</label>
                                <input type="text" class="form-control form-control-sm" id="subjectFilter" value="@subjectFilter" @oninput="OnSubjectFilterChanged" placeholder="Search by subject...">
                            </div>
                            <div>
                                <label for="bodyFilter" class="form-label small mb-1">Body Content</label>
                                <input type="text" class="form-control form-control-sm" id="bodyFilter" value="@bodyFilter" @oninput="OnBodyFilterChanged" placeholder="Search in message body...">
                            </div>
                        </div>
                        
                        @* Background search info for large message counts *@
                        @if (ShouldShowBackgroundSearchOption)
                        {
                            <div class="card-footer bg-info bg-opacity-10 border-info border-opacity-25 py-2">
                                <div class="d-flex align-items-start">
                                    <i class="bi bi-hourglass-split text-info me-2 mt-1"></i>
                                    <div class="small">
                                        <strong>Deep Search Mode</strong><br/>
                                        This entity has <strong>@MessageCount.ToString("N0")</strong> messages. 
                                        With filters active, the search will run in the background and scan up to 1M messages.
                                        You can monitor progress in Running Tasks.
                                    </div>
                                </div>
                            </div>
                        }
                    </div>
                </div>
                <div class="modal-footer">
                    <button type="button" class="btn btn-secondary" @onclick="Close">Cancel</button>
                    @if (ShouldShowBackgroundSearchOption)
                    {
                        <button type="button" class="btn btn-primary" @onclick="ExecuteBackgroundSearch" disabled="@(validationError != null || !HasActiveFilters)">
                            <i class="bi bi-hourglass-split"></i> Start Deep Search
                        </button>
                    }
                    else
                    {
                        <button type="button" class="btn btn-primary" @onclick="ExecutePeek" disabled="@(validationError != null)">
                            <i class="bi bi-search"></i> Peek
                        </button>
                    }
            </div>
        </div>
    </div>
    </div>
}

@code {
    [Parameter] public bool IsVisible { get; set; }
    [Parameter] public EventCallback OnClose { get; set; }
    [Parameter] public EventCallback<PeekOptions> OnPeek { get; set; }
    [Parameter] public EventCallback<PeekOptions> OnBackgroundSearch { get; set; }
    [Parameter] public PeekOptions? InitialOptions { get; set; }
    [Parameter] public long MessageCount { get; set; } = 0;
    
    /// <summary>
    /// Threshold above which we suggest background search when filters are active
    /// </summary>
    private const long BackgroundSearchThreshold = 10_000;

    private int maxCount = 50;
    private long fromSequenceNumber = 0;
    private string bodyFilter = "";
    private string messageIdFilter = "";
    private string subjectFilter = "";
    private bool peekFromNewest = false;
    private string? validationError = null;
    private bool mouseDownInContent = false;

    private bool HasMessageIdFilter => !string.IsNullOrWhiteSpace(messageIdFilter);
    private bool HasActiveFilters => !string.IsNullOrWhiteSpace(bodyFilter) || !string.IsNullOrWhiteSpace(messageIdFilter) || !string.IsNullOrWhiteSpace(subjectFilter);
    private int ActiveFilterCount => (string.IsNullOrWhiteSpace(bodyFilter) ? 0 : 1) + (string.IsNullOrWhiteSpace(messageIdFilter) ? 0 : 1) + (string.IsNullOrWhiteSpace(subjectFilter) ? 0 : 1);
    private bool ShouldShowBackgroundSearchOption => HasActiveFilters && MessageCount > BackgroundSearchThreshold;
    
    // Reverse peek (LIFO) is irrelevant/not supported when searching, as we scan from the start.
    // Also, when filters are active (client-side scan), we generally scan forward.
    private bool AllowReversePeek => !HasActiveFilters; 

    protected override void OnParametersSet()
    {
        // Reset to defaults or initial options when modal opens
        if (IsVisible)
        {
            if (InitialOptions != null)
            {
                maxCount = InitialOptions.MaxCount;
                fromSequenceNumber = InitialOptions.FromSequenceNumber;
                bodyFilter = InitialOptions.BodyFilter;
                messageIdFilter = InitialOptions.MessageIdFilter;
                subjectFilter = InitialOptions.SubjectFilter;
                peekFromNewest = InitialOptions.PeekFromNewest;
            }
            else
            {
                maxCount = 50;
                fromSequenceNumber = 0;
                bodyFilter = "";
                messageIdFilter = "";
                subjectFilter = "";
                peekFromNewest = false;
            }
            
            // Re-validate LIFO constraint
            if (!AllowReversePeek && peekFromNewest)
            {
                peekFromNewest = false;
            }
            
            // If Message ID filter is active, force Max Count to 1
            if (HasMessageIdFilter)
            {
                maxCount = 1;
            }
            
            validationError = null;
            mouseDownInContent = false;
        }
    }

    private int GetFilterMaxMessages()
    {
        return HasActiveFilters ? 50 : maxCount;
    }

    private void OnMaxCountChanged(ChangeEventArgs e)
    {
        if (HasMessageIdFilter) return;
        
        if (int.TryParse(e.Value?.ToString(), out var value))
        {
            maxCount = value;
            ValidateMaxCount();
        }
    }

    private void OnBodyFilterChanged(ChangeEventArgs e)
    {
        bodyFilter = e.Value?.ToString() ?? "";
        if (!AllowReversePeek && peekFromNewest) peekFromNewest = false;
        ValidateMaxCount(); // Re-validate when filter changes
    }

    private void OnMessageIdFilterChanged(ChangeEventArgs e)
    {
        messageIdFilter = e.Value?.ToString() ?? "";
        if (!AllowReversePeek && peekFromNewest) peekFromNewest = false;
        
        // Force MaxCount to 1 if Message ID filter is present
        if (HasMessageIdFilter) maxCount = 1;
        
        ValidateMaxCount();
    }

    private void OnSubjectFilterChanged(ChangeEventArgs e)
    {
        subjectFilter = e.Value?.ToString() ?? "";
        if (!AllowReversePeek && peekFromNewest) peekFromNewest = false;
        ValidateMaxCount();
    }

    private void OnPeekFromNewestChanged(ChangeEventArgs e)
    {
        peekFromNewest = (bool)(e.Value ?? false);
        if (peekFromNewest)
        {
            fromSequenceNumber = 0; // Reset when switching to reverse mode
        }
    }

    private void ValidateMaxCount()
    {
        if (maxCount < 1)
        {
            validationError = "Max messages must be at least 1";
        }
        else if (maxCount > 250)
        {
            validationError = "Max messages must be 250 or less (Azure Service Bus limit)";
        }
        else
        {
            validationError = null;
        }
    }

    private void HandleContentMouseDown()
    {
        mouseDownInContent = true;
    }

    private void HandleBackdropMouseUp()
    {
        // Only close if the mouse down didn't happen in the content
        if (!mouseDownInContent)
        {
            _ = Close();
        }
        mouseDownInContent = false;
    }

    private async Task Close()
    {
        await OnClose.InvokeAsync();
    }

    private async Task ExecutePeek()
    {
        // Validate maxCount
        ValidateMaxCount();
        if (validationError != null)
        {
            return;
        }
        
        // Clamp values
        maxCount = Math.Clamp(maxCount, 1, 250);
        fromSequenceNumber = Math.Max(0, fromSequenceNumber);
        
        var options = new PeekOptions
        {
            MaxCount = maxCount,
            FromSequenceNumber = peekFromNewest ? 0 : fromSequenceNumber,  // Will be calculated later if peekFromNewest is true
            BodyFilter = bodyFilter?.Trim() ?? "",
            MessageIdFilter = messageIdFilter?.Trim() ?? "",
            SubjectFilter = subjectFilter?.Trim() ?? "",
            PeekFromNewest = peekFromNewest
        };
        
        await OnPeek.InvokeAsync(options);
    }
    
    private async Task ExecuteBackgroundSearch()
    {
        if (!HasActiveFilters) return;
        
        var options = new PeekOptions
        {
            MaxCount = maxCount,
            FromSequenceNumber = 0,
            BodyFilter = bodyFilter?.Trim() ?? "",
            MessageIdFilter = messageIdFilter?.Trim() ?? "",
            SubjectFilter = subjectFilter?.Trim() ?? "",
            PeekFromNewest = false
        };
        
        await OnBackgroundSearch.InvokeAsync(options);
    }
}



@inject INotificationService NotificationService
@implements IDisposable

<div class="toast-container">
    @foreach (var notification in notifications)
    {
        <div class="toast show @GetToastClass(notification.Type)" role="alert">
            <div class="toast-header">
                <strong class="me-auto">@GetToastTitle(notification.Type)</strong>
                <button type="button" class="btn-close" @onclick="() => RemoveNotification(notification)"></button>
            </div>
            <div class="toast-body">
                @notification.Message
            </div>
        </div>
    }
</div>

@code {
    private List<NotificationItem> notifications = new();
    private Dictionary<string, NotificationItem> notificationsByKey = new();
    private Dictionary<NotificationItem, CancellationTokenSource> removalTimers = new();

    protected override void OnInitialized()
    {
        NotificationService.OnNotification += HandleNotification;
    }

    private void HandleNotification(NotificationEventArgs args)
    {
        // If an ID is provided, check if we should update an existing notification
        if (!string.IsNullOrEmpty(args.Id) && notificationsByKey.TryGetValue(args.Id, out var existing))
        {
            // Update existing notification
            existing.Message = args.Message;
            existing.Type = args.Type;
            
            // Reset the auto-remove timer
            ResetRemovalTimer(existing);
            StateHasChanged();
            return;
        }

        // Create new notification
        var notification = new NotificationItem
        {
            Id = Guid.NewGuid(),
            Key = args.Id,
            Message = args.Message,
            Type = args.Type
        };

        notifications.Add(notification);
        if (!string.IsNullOrEmpty(args.Id))
        {
            notificationsByKey[args.Id] = notification;
        }
        
        StartRemovalTimer(notification);
        StateHasChanged();
    }

    private void StartRemovalTimer(NotificationItem notification)
    {
        var cts = new CancellationTokenSource();
        removalTimers[notification] = cts;
        
        Task.Delay(5000, cts.Token).ContinueWith(_ =>
        {
            if (!cts.Token.IsCancellationRequested)
            {
                InvokeAsync(() => RemoveNotification(notification));
            }
        }, TaskContinuationOptions.OnlyOnRanToCompletion);
    }

    private void ResetRemovalTimer(NotificationItem notification)
    {
        // Cancel existing timer
        if (removalTimers.TryGetValue(notification, out var existingCts))
        {
            existingCts.Cancel();
            existingCts.Dispose();
        }
        
        // Start new timer
        StartRemovalTimer(notification);
    }

    private void RemoveNotification(NotificationItem notification)
    {
        notifications.Remove(notification);
        
        if (!string.IsNullOrEmpty(notification.Key))
        {
            notificationsByKey.Remove(notification.Key);
        }
        
        if (removalTimers.TryGetValue(notification, out var cts))
        {
            cts.Cancel();
            cts.Dispose();
            removalTimers.Remove(notification);
        }
        
        StateHasChanged();
    }

    private string GetToastClass(NotificationType type) => type switch
    {
        NotificationType.Success => "bg-success text-white",
        NotificationType.Error => "bg-danger text-white",
        NotificationType.Warning => "bg-warning",
        NotificationType.Info => "bg-info text-white",
        _ => ""
    };

    private string GetToastTitle(NotificationType type) => type switch
    {
        NotificationType.Success => "✓ Success",
        NotificationType.Error => "✗ Error",
        NotificationType.Warning => "⚠ Warning",
        NotificationType.Info => "ℹ Info",
        _ => "Notification"
    };

    public void Dispose()
    {
        NotificationService.OnNotification -= HandleNotification;
        
        foreach (var cts in removalTimers.Values)
        {
            cts.Cancel();
            cts.Dispose();
        }
        removalTimers.Clear();
    }

    private class NotificationItem
    {
        public Guid Id { get; set; }
        public string? Key { get; set; }
        public string Message { get; set; } = string.Empty;
        public NotificationType Type { get; set; }
    }
}
